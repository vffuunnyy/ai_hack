# Решение задачи «Расчет аэро- и газодинамики в ограниченном пространстве с использованием искусственного интеллекта»

## Описание задачи
Участникам предлагается попробовать отойти от традиционного метода расчета гидрогазодинамики численными методами моделирования (computational fluid dynamics - CFD) и разработать суррогатную модель машинного обучения, которая должная предсказывать коэффициент сопротивления Cd.

В качестве исходных данных для обучения модели представляются:

3D-модели автомобилей: в общей сложности 4000 объектов в формате STL, представляющие различные традиционные формы автомобилей с незначительными геометрическими модификациями, влияющими на аэродинамическую эффективность.
Общие результаты CFD симуляции

## Решение

#### Библиотеки

```markdown
- numpy>=2.1.3
- pandas>=2.2.3
- torch-geometric>=2.6.1
- torch>=2.5.1
- torch-cluster>=1.6.3
- torch-scatter>=2.1.2
- scikit-learn>=1.5.2
- mesh-reducer>=2.0.0
```

> Специально для этой задачи была написана библиотека на **rust** для чтения и обработки 3D моделей в формате STL - [mesh-reducer](https://github.com/vffuunnyy/mesh-reducer)
> Преимущества библиотеки:
> - *Параллельная обработка*: Использование rayon для параллельной обработки данных позволяет значительно ускорить вычисления, особенно при работе с большими STL-файлами.
> - *Интеграция с Python*: С помощью pyo3 библиотека предоставляет интерфейс для использования в Python, что делает её более доступной.
> - *Гибкость и масштабируемость*: Возможность задавать количество кластеров для выборки точек (или списка кластеров) позволяет адаптировать библиотеку под различные задачи и объёмы данных.

#### Структура проекта

```markdown
- models/ - папка с моделями машинного обучения
- assets/ - папка с 3D моделями
- config.py - настройки проекта
- train.py - скрипт для обучения модели
- model.py - модель нейронной сети
- utils.py - вспомогательные функции
```

#### Модель

Модель `RegDGCNN` представляет собой регрессионную модель на основе динамических сверточных слоев графов (`DynamicEdgeConv`) с применением механизма `FiLM` (`Feature-wise Linear Modulation`). Она состоит из нескольких сверточных слоев, каждый из которых поддерживает адаптивное взвешивание с учетом контекста (`FiLM`). После сверточных слоев используется глобальный средний пул для агрегации представлений, а затем несколько полносвязных слоев для предсказания выходного значения.

Основные компоненты модели:

- `FiLM` модуляция для управления и изменения характеристик слоев.
- `DynamicEdgeConv` для обработки топологии данных.
- Полносвязные слои с `BatchNorm` и `Dropout` для стабилизации и улучшения обучения.


#### Подготовка данных

1. **Настройки и чтение данных:**
    - Параметры обработки данных задаются в файле config.py.
    ```python
    LOAD_BEST_MODEL = False                          # Нужно ли загружать лучшую модель для дообучения

    MODELS_PATH = Path("./models")                   # Папка с обученными моделями
    ASSETS_PATH = Path("./assets")                   # Папка с 3д моделями автомобилей
    RESULTS_FILE = ASSETS_PATH / "data.csv"          # Файл с данными для обучения

    POINTS_RANGE = list(range(1024, 4096 + 1, 256))  # Кол-во точек в облаке
    READ_ASSETS_LIMIT = None                         # Лимит на кол-во загружаемых 3д моделей

    EPOCHS_COUNT = 10_000     # Кол-во эпох
    BATCH_SIZE = 16           # Кол-во облаков точек в батче
    STOP_LOSS_PATIENCE = 256  # Останавливать обучение если не было улчшения
    BETA = 0.05
    ```
    - Данные загружаются с помощью функции `read_assets` и включают облака точек (`point_clouds`)
2. **Масштабирование данных:**
    - Нормализация целевых значений с использованием StandardScaler.
3. **Подготовка данных:**
    - Формируется список объектов `Data` для работы с PyTorch Geometric.
    - Создание объектов `Data` для работы с `PyTorch Geometric` и разделение данных на обучающую, валидационную и тестовую выборки.

#### Обучение модели

1. **Настройка оптимизатора и функции потерь**
    ```python
    optimizer = torch.optim.Adam(model.parameters(), lr=0.0001, weight_decay=1e-5)
    scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=20, gamma=0.5)
    criterion = nn.MSELoss()  # Среднеквадратичная ошибка
    ```
2. **Процесс обучения с учетом взаимодействия с предварительно обученной моделью**
   - Применение случайного вращения облаков точек для улучшения генерализации.
   - Регуляризация через сравнение представлений с предварительно обученной сетью.

3. **Оценка модели:**
    - Вычисление средней абсолютной процентной ошибки (MAPE)
    - Визуализация результатов.


## Запуск

1. Установка conda и зависимостей:
[Установка conda](https://www.anaconda.com/download/)
```bash
conda env create -f environment.yml
```

2. Обучение модели:
```bash
python train.py
```

3. После обучения модели, можно использовать ее для предсказания коэффициента сопротивления:
```python
from models import RegDGCNN
import torch

model = RegDGCNN()
model.load_state_dict(torch.load("./models/best_model.pth", weights_only=True))
model.eval()

# Предсказание коэффициента сопротивления
cd_pred = model(data)
```